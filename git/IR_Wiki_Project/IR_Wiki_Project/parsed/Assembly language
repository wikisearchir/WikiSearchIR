title
See the terminology section below for information regarding inconsistent use of the terms assembly and assembler.

An assembly language is a low-level programming language for computers, microprocessors, microcontrollers, and other programmable devices. It implements a symbolic representation of the machine codes and other constants needed to program a given CPU architecture. This representation is usually defined by the hardware manufacturer, and is based on mnemonics that symbolize processing steps (instructions), processor registers, memory locations, and other language features. An assembly language is thus specific to a certain physical (or virtual) computer architecture. This is in contrast to most high-level programming languages, which, ideally, are portable.A utility program called an assembler is used to translate assembly language statements into the target computer's machine code. The assembler performs a more or less isomorphic translation (a one-to-one mapping) from mnemonic statements into machine instructions and data. This is in contrast with high-level languages, in which a single statement generally results in many machine instructions.Many advanced assemblers offer additional mechanisms to facilitate program development, control the assembly process, and aid debugging. In particular, most modern assemblers include a macro facility (described below), and are called macro assemblers.
Key concepts
Assembler

Compare with: Microassembler.
Typically a modern assembler creates object code by translating assembly instruction mnemonics into opcodes, and by resolving symbolic names for memory locations and other entities.David Salomon (1993). Assemblers and Loaders The use of symbolic references is a key feature of assemblers, saving tedious calculations and manual address updates after program modifications. Most assemblers also include macro facilities for performing textual substitution&mdash;e.g., to generate common short sequences of instructions as inline, instead of called subroutines.Assemblers are generally simpler to write than compilers for high-level languages,{{cn}} and have been available since the 1950s. Modern assemblers, especially for RISC architectures, such as SPARC or POWER, as well as x86 and x86-64, optimize Instruction scheduling to exploit the CPU pipeline efficiently.{{cn}}
Number of passes
There are two types of assemblers based on how many passes through the source are needed to produce the executable program.

One-pass assemblers go through the source code once. Any symbol used before it is defined will require &#34;errata&#34; at the end of the object code (or, at least, no earlier than the point where the symbol is defined) telling the linker or the loader to &#34;go back&#34; and overwrite a placeholder which had been left where the as yet undefined symbol was used.
Multi-pass assemblers create a table with all symbols and their values in the first passes, then use the table in later passes to generate code.
In both cases, the assembler must be able to determine the size of each instruction on the initial passes in order to calculate the addresses of symbols. This means that if the size of an operation referring to an operand defined later depends on the type or distance of the operand, the assembler will make a pessimistic estimate when first encountering the operation, and if necessary pad it with one or more &#34;no-operation&#34; instructions in a later pass or the errata. In an assembler with peephole optimization addresses may be recalculated between passes to allow replacing pessimistic code with code tailored to the exact distance from the target.

The original reason for the use of one-pass assemblers was speed of assembly; however, modern computers perform multi-pass assembly without unacceptable delay.  The advantage of the multi-pass assembler is that the absence of a need for errata makes the linker (or the loader if the assembler directly produces executable code) simpler and faster.{{Cite book}}
High-level assemblers
More sophisticated high-level assemblers provide language abstractions such as:

Advanced control structures
High-level procedure/function declarations and invocations
High-level abstract data types, including structures/records, unions, classes, and sets
Sophisticated macro processing (although available on ordinary assemblers since late 1950s for IBM 700 series and since 1960&#39;s for IBM/360, amongst other machines)
Object-oriented programming features such as classes, objects, abstraction, polymorphism, and inheritanceHyde, Randall. "Chapter 12 – Classes and Objects". The Art of Assembly Language, 2nd Edition. No Starch Press. © 2010.
See Language design below for more details.
Use of the term
Note that, in normal professional usage, the term assembler is used to refer both to an assembly language, and to software which assembles an assembly-language program. Thus: "CP/CMS was written in S/360 assembler" as well as "ASM-H was a widely-used S/370 assembler."{{Citation needed}}
Assembly languageA program written in assembly language consists of a series of (mnemonic) processor instructions and meta-statements (known variously as directives, pseudo-instructions and pseudo-ops), comments and data. Assembly language instructions usually consist of an opcode mnemonic followed by a comma-separated list of data, arguments or parameters.{{cite book}}These are translated by an assembler to a stream of executable instructions that can be loaded into memory and executed. Assemblers can also be used to produce blocks of data from formatted and commented source code, to be used by other code.Take, for example, the instruction that tells an x86/IA-32 processor to move an immediate 8-bit value into a register. The binary code for this instruction is 10110 followed by a 3-bit identifier for which register to use. The identifier for the AL register is 000, so the following machine code loads the AL register with the data 01100001.{{cite book}}10110000 01100001This binary computer code can be made more human-readable by expressing it in hexadecimal as followsB0 61Here, B0 means 'Move a copy of the following value into AL, and 61 is a hexadecimal representation of the value 01100001, which is 97 in decimal. Intel assembly language provides the mnemonic MOV (an abbreviation of move) for instructions such as this, so the machine code above can be written as follows in assembly language, complete with an explanatory comment if required, after the semicolon. This is much easier to read and to remember.
MOV AL, 61h       ; Load AL with 97 decimal (61 hex)
At one time many assembly language mnemonics were three letter abbreviations, such as JMP for jump, INC for increment, etc. Modern processors have a much larger instruction set and many mnemonics are now longer, for example FPATAN for "floating point partial arctangent" and BOUND for "check array index against bounds". The same mnemonic MOV refers to a family of related opcodes to do with loading, copying and moving data, whether these are immediate values, values in registers, or memory locations pointed to by values in registers.  The opcode 10110000 (B0) copies an 8-bit value into the AL register, while 10110001 (B1) moves it into CL and 10110010 (B2) does so into DL. Assembly language examples for these follow.

MOV AL, 1h        ; Load AL with immediate value 1
MOV CL, 2h        ; Load CL with immediate value 2
MOV DL, 3h        ; Load DL with immediate value 3
The syntax of MOV can also be more complex as the following examples show.{{cite web}}

MOV EAX, [EBX]	  ; Move the 4 bytes in memory at the address contained in EBX into EAX
MOV [ESI+EAX], CL ; Move the contents of CL into the byte at address ESI+EAX
In each case, the MOV mnemonic is translated directly into an opcode in the ranges 88-8E, A0-A3, B0-B8, C6 or C7 by an assembler, and the programmer does not have to know or remember which.Transforming assembly language into machine code is the job of an assembler, and the reverse can at least partially be achieved by a disassembler. Unlike high-level languages, there is usually a one-to-one correspondence between simple assembly statements and machine language instructions. However, in some cases, an assembler may provide pseudoinstructions (essentially macros) which expand into several machine language instructions to provide commonly needed functionality. For example, for a machine that lacks a "branch if greater or equal" instruction, an assembler may provide a pseudoinstruction that expands to the machine's "set if less than" and "branch if zero (on the result of the set instruction)". Most full-featured assemblers also provide a rich macro language (discussed below) which is used by vendors and programmers to generate more complex code and data sequences.Each computer architecture and processor architecture usually has its own machine language.
On this level, each instruction is simple enough to be executed using a relatively small number of electronic circuits. Computers differ by the number and type of operations they support. For example, a machine with a 64-bit word length would have different circuitry from a 32-bit machine. They may also have different sizes and numbers of registers, and different representations of data types in storage. While most general-purpose computers are able to carry out essentially the same functionality, the ways they do so differ; the corresponding assembly languages may reflect these differences.Multiple sets of mnemonics or assembly-language syntax may exist for a single instruction set, typically instantiated in different assembler programs. In these cases, the most popular one is usually that supplied by the manufacturer and used in its documentation.
Language design
Basic elementsThere is a large degree of diversity in the way the authors of assemblers categorize statements and in the nomenclature that they use. In particular, some describe anything other than a machine mnemonic or extended mnemonic as a pseudo-operation (pseudo-op). A typical assembly language consists of 3 types of instruction statements that are used to define program operations:

Opcode mnemonics
Data sections
Assembly directives


Opcode mnemonics and extended mnemonicsInstructions (statements) in assembly language are generally very simple, unlike those in high-level language. Generally, a mnemonic is a symbolic name for a single executable machine language instruction (an opcode), and there is at least one opcode mnemonic defined for each machine language instruction. Each instruction typically consists of an operation or opcode plus zero or more operands. Most instructions refer to a single value, or a pair of values.  Operands can be immediate (typically one byte values, coded in the instruction itself), registers specified in the instruction, implied or the addresses of data located elsewhere in storage. This is determined by the underlying processor architecture: the assembler merely reflects how this architecture works. Extended mnemonics are often used to specify a combination of an opcode with a specific operand, e.g., the System/360 assemblers use B as an extended mnemonic for BC with a mask of 15 and NOP for BC with a mask of 0.Extended mnemonics are often used to support specialized uses of instructions, often for purposes not obvious from the instruction name. For example, many CPU's do not have an explicit NOP instruction, but do have instructions that can be used for the purpose. In 8086 CPUs the instruction xchg ax,ax is used for nop, with nop being a pseudo-opcode to encode the instruction xchg ax,ax. Some disassemblers recognize this and will decode the xchg ax,ax instruction as nop. Similarly, IBM assemblers for System/360 and System/370 use the extended mnemonics NOP and NOPR for BC and BCR with zero masks.Some assemblers also support simple built-in macro-instructions that generate two or more machine instructions. For instance, with some Z80 assemblers the instruction ld hl,bc is recognized to generate ld l,c followed by ld h,b.http://www.z80.de/z80/z80code.htm These are sometimes known as pseudo-opcodes.
Data sectionsThere are instructions used to define data elements to hold data and variables.  They define the type of data, the length and the alignment of data. These instructions can also define whether the data is available to outside programs (programs assembled separately) or only to the program in which the data section is defined. Some assemblers classify these as pseudo-ops.
Assembly directivesAssembly directives, also called pseudo opcodes, pseudo-operations or pseudo-ops, are instructions that are executed by an assembler at assembly time, not by a CPU at run time.  They can make the assembly of the program dependent on parameters input by a programmer, so that one program can be assembled different ways, perhaps for different applications.  They also can be used to manipulate presentation of a program to make it easier to read and maintain.(For example, directives would be used to reserve storage areas and optionally their initial contents.) The names of directives often start with a dot to distinguish them from machine instructions.Symbolic assemblers let programmers associate arbitrary names (labels or symbols) with memory locations. Usually, every constant and variable is given a name so instructions can reference those locations by name, thus promoting self-documenting code. In executable code, the name of each subroutine is associated with its entry point, so any calls to a subroutine can use its name. Inside subroutines, GOTO destinations are given labels. Some assemblers support local symbols which are lexically distinct from normal symbols (e.g., the use of "10$" as a GOTO destination).Some{{which?}} assemblers provide flexible symbol management, letting programmers manage different namespaces, automatically calculate offsets within data structures, and assign labels that refer to literal values or the result of simple computations performed by the assembler. Labels can also be used to initialize constants and variables with relocatable addresses.Assembly languages, like most other computer languages, allow comments to be added to assembly source code that are ignored by the assembler. Good use of comments is even more important with assembly code than with higher-level languages, as the meaning and purpose of a sequence of instructions is harder to decipher from the code itself.Wise use of these facilities can greatly simplify the problems of coding and maintaining low-level code. Raw assembly source code as generated by compilers or disassemblers—code without any comments, meaningful symbols, or data definitions—is quite difficult to read when changes must be made.
MacrosMany assemblers support predefined macros, and others support programmer-defined (and repeatedly re-definable) macros involving sequences of text lines in which variables and constants are embedded. This sequence of text lines may include opcodes or directives. Once a macro has been defined its name may be used in place of a mnemonic. When the assembler processes such a statement, it replaces the statement with the text lines associated with that macro, then processes them as if they existed in the source code file (including, in some assemblers, expansion of any macros existing in the replacement text).Note that this definition of "macro" is slightly different from the use of the term in other contexts, like the C programming language. C macro's created through the #define directive typically are just one line, or a few lines at most. Assembler macro instructions can be lengthy "programs" by themselves, executed by interpretation by the assembler during assembly.   Since macros can have 'short' names but expand to several or indeed many lines of code, they can be used to make assembly language programs appear to be far shorter, requiring fewer lines of source code, as with higher level languages. They can also be used to add higher levels of structure to assembly programs, optionally introduce embedded debugging code via parameters and other similar features.Many assemblers have built-in (or predefined) macros for system calls and other special code sequences, such as the generation and storage of data realized through advanced bitwise and boolean operations used in gaming, software security, data management, and cryptography.Macro assemblers often allow macros to take parameters. Some assemblers include quite sophisticated macro languages, incorporating such high-level language elements as optional parameters, symbolic variables, conditionals, string manipulation, and arithmetic operations, all usable during the execution of a given macro, and allowing macros to save context or exchange information. Thus a macro might generate a large number of assembly language instructions or data definitions, based on the macro arguments. This could be used to generate record-style data structures or "unrolled" loops, for example, or could generate entire algorithms based on complex parameters. An organization using assembly language that has been heavily extended using such a macro suite can be considered to be working in a higher-level language, since such programmers are not working with a computer's lowest-level conceptual elements.Macros were used to customize large scale software systems for specific customers in the mainframe era and were also used by customer personnel to satisfy their employers' needs by making specific versions of manufacturer operating systems. This was done, for example, by systems programmers working with IBM's Conversational Monitor System / Virtual Machine (CMS/VM) and with IBM's "real time transaction processing" add-ons, CICS, Customer Information Control System,  and ACP/TPF, the airline/financial system that began in the 1970s and still runs many large computer reservations systems (CRS) and credit card systems today.It was also possible to use solely the macro processing abilities of an assembler to generate code written in completely different languages, for example, to generate a version of a program in COBOL using a pure macro assembler program containing lines of COBOL code inside assembly time operators instructing the assembler to generate arbitrary code.This was because, as was realized in the 1960s, the concept of "macro processing" is independent of the concept of "assembly", the former being in modern terms more word processing, text processing, than generating object code. The concept of macro processing appeared, and appears, in the C programming language, which supports "preprocessor instructions" to set variables, and make conditional tests on their values. Note that unlike certain previous macro processors inside assemblers, the C preprocessor was not Turing-complete because it lacked the ability to either loop or "go to", the latter allowing programs to loop.Despite the power of macro processing, it fell into disuse in many high level languages (major exceptions being C/C++ and PL/I) while remaining a perennial for assemblers.  Macro parameter substitution is strictly by name: at macro processing time, the value of a parameter is textually substituted for its name. The most famous class of bugs resulting was the use of a parameter that itself was an expression and not a simple name when the macro writer expected a name. In the macro:

foo: macro a
load a*b

the intention was that the caller would provide the name of a variable, and the "global" variable or constant b would be used to multiply "a". If foo is called with the parameter a-c, the macro expansion of load a-c*b occurs.  To avoid any possible ambiguity, users of macro processors can parenthesize formal parameters inside macro definitions, or callers can parenthesize the input parameters.{{Cite web}}PL/I and C/C++ feature macros, but this facility can only manipulate text.  On the other hand, homoiconic languages, such as Lisp, Prolog, and Forth, retain the power of assembly language macros because they are able to manipulate their own code as data.
Support for structured programmingSome assemblers have incorporated structured programming elements to encode execution flow. The earliest example of this approach was in the Concept-14 macro set, originally proposed by Dr. H.D. Mills (March, 1970), and implemented by Marvin Kessler at IBM's Federal Systems Division, which extended the S/360 macro assembler with IF/ELSE/ENDIF and similar control flow blocks.{{Cite web}} This was a way to reduce or eliminate the use of GOTO operations in assembly code, one of the main factors causing spaghetti code in assembly language. This approach was widely accepted in the early 80s (the latter days of large-scale assembly language use).A curious design was A-natural, a "stream-oriented" assembler for 8080/Z80 processors{{Citation needed}} from Whitesmiths Ltd. (developers of the Unix-like Idris operating system, and what was reported to be the first commercial C compiler). The language was classified as an assembler, because it worked with raw machine elements such as opcodes, registers, and memory references; but it incorporated an expression syntax to indicate execution order. Parentheses and other special symbols, along with block-oriented structured programming constructs, controlled the sequence of the generated instructions. A-natural was built as the object language of a C compiler, rather than for hand-coding, but its logical syntax won some fans.There has been little apparent demand for more sophisticated assemblers since the decline of large-scale assembly language development.{{Cite web}} In spite of that, they are still being developed and applied in cases where resource constraints or peculiarities in the target system's architecture prevent the effective use of higher-level languages.NESHLA: The High Level, Open Source, 6502 Assembler for the Nintendo Entertainment System
Use of assembly language
Historical perspectiveAssembly languages were first developed in the 1950s, when they were referred to as second generation programming languages. Nathaniel Rochester wrote the first assembler for an IBM 701.For example, SOAP (Symbolic Optimal Assembly Program) was a 1957 assembly language for the IBM 650 computer.  Assembly languages eliminated much of the error-prone and time-consuming first-generation programming needed with the earliest computers, freeing programmers from tedium such as remembering numeric codes and calculating addresses. They were once widely used for all sorts of programming. However, by the 1980s (1990s on microcomputers), their use had largely been supplanted by high-level languages{{Citation needed}}, in the search for improved programming productivity. Today, although assembly language is almost always handled and generated by compilers, it is still used for direct hardware manipulation, access to specialized processor instructions, or to address critical performance issues. Typical uses are device drivers, low-level embedded systems, and real-time systems.Historically, a large number of programs have been written entirely in assembly language. Operating systems were almost exclusively written in assembly language until the widespread acceptance of C in the 1970s and early 1980s. Many commercial applications were written in assembly language as well, including a large amount of the IBM mainframe software written by large corporations. COBOL and FORTRAN eventually displaced much of this work, although a number of large organizations retained assembly-language application infrastructures well into the 90s.Most early microcomputers relied on hand-coded assembly language, including most operating systems and large applications. This was because these systems had severe resource constraints, imposed idiosyncratic memory and display architectures, and provided limited, buggy system services. Perhaps more important was the lack of first-class high-level language compilers suitable for microcomputer use. A psychological factor may have also played a role: the first generation of microcomputer programmers retained a hobbyist, "wires and pliers" attitude.In a more commercial context, the biggest reasons for using assembly language were minimal bloat (size), minimal overhead, greater speed, and reliability.Typical examples of large assembly language programs from this time are IBM PC DOS operating systems and early applications such as the spreadsheet program Lotus 1-2-3. Even into the 1990s, most console video games were written in assembly, including most games for the Mega Drive/Genesis and the Super Nintendo Entertainment System {{Citation needed}}. According to some industry insiders, the assembly language was the best computer language to use to get the best performance out of the Sega Saturn, a console that was notoriously challenging to develop and program games for.Eidolon's Inn : SegaBase Saturn The popular arcade game NBA Jam (1993) is another example. Assembly language has long been the primary development language for many popular home computers of the 1980s and 1990s (such as the Sinclair ZX Spectrum, Commodore 64, Commodore Amiga, and Atari ST). This was in large part because BASIC dialects on these systems offered insufficient execution speed, as well as insufficient facilities to take full advantage of the available hardware on these systems. Some systems, most notably the Amiga, even have IDEs with highly advanced debugging and macro facilities, such as the freeware ASM-One assembler, comparable to that of Microsoft Visual Studio facilities (ASM-One predates Microsoft Visual Studio).The Assembler for the VIC-20 was written by Don French and published by French Silk. At 1639 bytes in length, its author believes it is the smallest symbolic assembler ever written. The assembler supported the usual symbolic addressing and the definition of character strings or hex strings. It also allowed address expressions which could be combined with addition, subtraction, multiplication, division, logical AND, logical OR, and exponentiation operators.{{Cite web}}
Current usageThere have always been debates over the usefulness and performance of assembly language relative to high-level languages. Assembly language has specific niche uses where it is important; see below. But in general, modern optimizing compilers are claimed{{Citation needed}} to render high-level languages into code that can run as fast as hand-written assembly, despite the counter-examples that can be found.{{Cite web}}{{Cite web}}{{Cite web}} The complexity of modern processors and memory sub-system makes effective optimization increasingly difficult for compilers, as well as assembly programmers.{{Cite web}}{{Cite web}} Moreover, and to the dismay of efficiency lovers, increasing processor performance has meant that most CPUs sit idle most of the time,{{Citation needed}} with delays caused by predictable bottlenecks such as I/O operations and paging. This has made raw code execution speed a non-issue for many programmers.There are some situations in which practitioners might choose to use assembly language, such as when:

a stand-alone binary executable of compact size is required, i.e. one that must execute without recourse to the run-time components or libraries associated with a high-level language; this is perhaps the most common situation. These are embedded single-tasking programs, and use only a relatively small amount of memory. Examples include firmware for telephones, automobile fuel and ignition systems, air-conditioning control systems, security systems, and sensors.
particularly, a system with severe resource constraints (e.g., an embedded system) must be hand-coded to maximize the use of limited resources; but this is becoming less common as processor price decreases and performance improves.
interacting directly with the hardware, for example in device drivers and interrupt handlers.
using processor-specific instructions not implemented in a compiler. A common example is the bitwise rotation instruction at the core of many encryption algorithms.
creating vectorized functions for programs in higher-level languages such as C.  In the higher-level language this is sometimes aided by compiler intrinsic functions which map directly to SIMD mnemonics, but nevertheless result in a one-to-one assembly conversion specific for the given vector processor.
extreme optimization is required, e.g., in an inner loop in a processor-intensive algorithm. Game programmers take advantage of the abilities of hardware features in systems, enabling games to run faster. Also large scientific simulations require highly optimized algorithms, e.g. linear algebra with BLAS{{cite web}} or discrete cosine transformation (e.g. SIMD assembly version from x264{{cite web}})
no high-level language exists, on a new or specialized processor, for example.
programs need precise timing such as
real-time programs that need precise timing and responses, such as simulations, flight navigation systems, and medical equipment. For example, in a fly-by-wire system, telemetry must be interpreted and acted upon within strict time constraints. Such systems must eliminate sources of unpredictable delays, which may be created by (some) interpreted languages, automatic garbage collection, paging operations, or preemptive multitasking. However, some higher-level languages incorporate run-time components and operating system interfaces that can introduce such delays. Choosing assembly or lower-level languages for such systems gives programmers greater visibility and control over processing details.
cryptographic algorithms that must always take strictly the same time to execute, preventing timing attacks.
complete control over the environment is required, in extremely high security situations where nothing can be taken for granted.
writing computer viruses, bootloaders, certain device drivers, or other items very close to the hardware or low-level operating system.
writing instruction set simulators for monitoring, tracing and debugging where additional overhead is kept to a minimum
reverse-engineering and modifying program files such as
existing binaries that may or may not have originally been written in a high-level language, for example when trying to recreate programs for which source code is not available or has been lost, or cracking copy protection of proprietary software.
video games (also termed ROM hacking), which is possible via several methods. The most widely employed is altering program code at the assembly language level.
writing self modifying code, to which assembly language lends itself well.
writing games and other software for graphing calculators.{{Cite web}}
writing compiler software that generates assembly code; the programmers must be expert assembly language programmers to generate correct assembly code.

Assembly language is still taught in most computer science and electronic engineering programs. Although few programmers today regularly work with assembly language as a tool, the underlying concepts remain very important. Such fundamental topics as binary arithmetic, memory allocation, stack processing, character set encoding, interrupt processing, and compiler design would be hard to study in detail without a grasp of how a computer operates at the hardware level. Since a computer's behavior is fundamentally defined by its instruction set, the logical way to learn such concepts is to study an assembly language. Most modern computers have similar instruction sets. Therefore, studying a single assembly language is sufficient to learn: I) the basic concepts; II) to recognize situations where the use of assembly language might be appropriate; and III) to see how efficient executable code can be created from high-level languages.
{{Cite web}} This is analogous to children needing to learn the basic arithmetic operations (e.g., long division), although calculators are widely used for all except the most trivial calculations.
Typical applicationsHard-coded assembly language is typically used in a system's boot ROM (BIOS on IBM-compatible PC systems). This low-level code is used, among other things, to initialize and test the system hardware prior to booting the OS, and is stored in ROM. Once a certain level of hardware initialization has taken place, execution transfers to other code, typically written in higher level languages; but the code running immediately after power is applied is usually written in assembly language. The same is true of most boot loaders.Many compilers render high-level languages into assembly first before fully compiling, allowing the assembly code to be viewed for debugging and optimization purposes. Relatively low-level languages, such as C, often provide special syntax to embed assembly language directly in the source code. Programs using such facilities, such as the Linux kernel, can then construct abstractions using different assembly language on each hardware platform. The system's portable code can then use these processor-specific components through a uniform interface.Assembly language is also valuable in reverse engineering, since many programs are distributed only in machine code form, and machine code is usually easy to translate into assembly language and carefully examine in this form, but very difficult to translate into a higher-level language. Tools such as the Interactive Disassembler make extensive use of disassembly for such a purpose.One niche that makes use of assembly language is the demoscene. Certain competitions require contestants to restrict their creations to a very small size (e.g. 256B, 1KB, 4KB or 64 KB), and assembly language is the language of choice to achieve this goal.{{Cite web}} When resources, especially CPU processing-constrained systems, like the earlier Amiga models, and the Commodore 64, are a concern, assembler coding is a must. Optimized assembler code is written "by hand" and instructions are sequenced manually by programmers in an attempt to minimize the number of CPU cycles used. The CPU constraints are so great that every CPU cycle counts. However, using such methods has enabled systems like the Commodore 64 to produce real-time 3D graphics with advanced effects, a feat which might be considered unlikely or even impossible for a system with a 1.02MHz processor. {{Citation needed}}
Related terminology

Assembly language or assembler language is commonly called assembly, assembler, ASM, or symbolic machine code. A generation of IBM mainframe programmers called it ALC for Assembly Language Code or BALTechically BAL was only the assembler for BPS; the others were macro assemblers. for Basic Assembly Language.




Note: Calling the language assembler is of course potentially confusing and ambiguous, since this is also the name of the utility program that translates assembly language statements into machine code. Some may regard this as imprecision or error. However, this usage has been common among professionals and in the literature for decades.Stroustrup, Bjarne, The C++ Programming Language, Addison-Wesley, 1986, ISBN 0-201-12078-X: "C++ was primarily designed so that the author and his friends would not have to program in assembler, C, or various modern high-level languages. [use of the term assembler to mean assembly language]" Similarly, some early computers called their assembler their assembly program.Saxon, James, and Plette, William, Programming the IBM 1401, Prentice-Hall, 1962, LoC 62-20615. [use of the term assembly program])
The computational step where an assembler is run, including all macro processing, is termed assembly time.
The use of the word assembly dates from the early years of computers (cf. short code, speedcode).
{{anchor}}A cross assembler (see cross compiler) is functionally just an assembler. This term is used to stress that the assembler is run on a computer or operating system of different  type and incompatible with the system on which the resulting code is to run. Cross-assembling may be necessary if the target system cannot run an assembler itself, as is typically the case for small embedded systems. A cross assembler must provide for or interface to facilities to transport the code to the target processor, e.g. to reside in flash or EPROM memory. It generates a binary image, or Intel HEX file rather than an object file.
An assembler directive or pseudo-opcode is a command given to an assembler. These directives may do anything from telling the assembler to include other source files, to telling it to allocate memory for constant data.


List of assemblers for different computer architecturesThe following page has a list of different assemblers for the different computer architectures, along with any associated information for that specific assembler:

List of assemblers


Further detailsFor any given personal computer, mainframe, embedded system, and game console, both past and present, at least one – possibly dozens – of assemblers have been written. For some examples, see the list of assemblers.On Unix systems, the assembler is traditionally called as, although it is not a single body of code, being typically written anew for each port. A number of Unix variants use GAS.Within processor groups, each assembler has its own dialect. Sometimes, some assemblers can read another assembler's dialect, for example, TASM can read old MASM code, but not the reverse. FASM and NASM have similar syntax, but each support different macros that could make them difficult to translate to each other. The basics are all the same, but the advanced features will differ.{{Cite web}}Also, assembly can sometimes be portable across different operating systems on the same type of CPU. Calling conventions between operating systems often differ slightly or not at all, and with care it is possible to gain some portability in assembly language, usually by linking with a C library that does not change between operating systems. An  instruction set simulator (which would ideally be written in an assembler language) can, in theory, process the object code/ binary of any assembler to achieve portability even across platforms (with an overhead no greater than a typical bytecode interpreter). This is essentially what microcode achieves when a hardware platform changes internally.For example, many things in libc depend on the preprocessor to do OS-specific, C-specific things to the program before compiling. In fact, some functions and symbols are not even guaranteed to exist outside of the preprocessor. Worse, the size and field order of structs, as well as the size of certain typedefs such as off_t, are entirely unavailable in assembly language without help from a configure script, and differ even between versions of Linux, making it impossible to portably call functions in libc other than ones that only take simple integers and pointers as parameters. To address this issue, FASMLIB project provides a portable assembly library for Win32 and Linux platforms, but it is yet very incomplete.{{Cite web}}Some higher level computer languages, such as C and Borland Pascal, support inline assembly where sections of assembly code, in practice usually brief, can be embedded into the high level language code. The Forth language commonly contains an assembler used in CODE words.An emulator can be used to debug assembly-language programs.
Example listing of assembly language source code

Address Label Instruction (AT&#38;T syntax) Object code{{Cite book}} 
  .begin  
  .org 2048  
 a_start .equ 3000  
2048  ld length,%  
2064  be done 00000010 10000000 00000000 00000110 
2068  addcc %r1,-4,%r1 10000010 10000000 01111111 11111100 
2072  addcc %r1,%r2,%r4 10001000 10000000 01000000 00000010 
2076  ld %r4,%r5 11001010 00000001 00000000 00000000 
2080  ba loop 00010000 10111111 11111111 11111011 
2084  addcc %r3,%r5,%r3 10000110 10000000 11000000 00000101 
2088 done: jmpl %r15+4,%r0 10000001 11000011 11100000 00000100 
2092 length: 20 00000000 00000000 00000000 00010100 
2096 address: a_start 00000000 00000000 00001011 10111000 
  .org a_start  
3000 a:   
Example of a selection of instructions (for a virtual computerPrinciples of Computer Architecture (POCA) &ndash; ARCTools virtual computer available for download to execute referenced code, accessed August 24, 2005) with the
corresponding address in memory where each instruction will be placed. These addresses are not static, see memory management.
Accompanying each instruction is the generated (by the assembler) object code that coincides with the virtual computer's architecture (or ISA).
See also

Compiler
Disassembler
Instruction set
Little man computer – an educational computer model with a base-10 assembly language
Microassembler
Typed assembly language


References{{Reflist}}
Further reading

ASM Community Book &#34;An online book full of helpful ASM info, tutorials and code examples&#34; by the ASM Community
Jonathan Bartlett: Programming from the Ground Up. Bartlett Publishing, 2004. ISBN 0-9752838-4-7Also available online as PDF
Robert Britton: MIPS Assembly Language Programming. Prentice Hall, 2003. ISBN 0-13-142044-5
Paul Carter: PC Assembly Language. Free ebook, 2001.Website
Jeff Duntemann: Assembly Language Step-by-Step. Wiley, 2000. ISBN 0-471-37523-3
Randall Hyde: The Art of Assembly Language. No Starch Press, 2003. ISBN 1-886411-97-2Draft versions available online as PDF and HTML
Peter Norton, John Socha, Peter Norton's Assembly Language Book for the IBM PC, Brady Books, NY: 1986.
Michael Singer, PDP-11. Assembler Language Programming and Machine Organization, John Wiley &#38; Sons, NY: 1980.
Dominic Sweetman: See MIPS Run. Morgan Kaufmann Publishers, 1999. ISBN 1-55860-410-3
John Waldron: Introduction to RISC Assembly Language Programming. Addison Wesley, 1998. ISBN 0-201-39828-1


External links{{External links}}
{{Wiktionary}}
{{Wikibooks}}

FASMARM 1.13 – FASM for ARM processors 04-Nov-2008
Randall Hyde's The Art of Assembly Language as HTML and PDF version
Machine language for beginners
Introduction to assembly language
The ASM Community, a programming resource about assembly including an ASM Book
Intel Assembly 80x86 CodeTable (a cheat sheet reference)
Unix Assembly Language Programming
IBM z/Architecture Principles of Operation IBM manuals on mainframe machine language and internals.
IBM High Level Assembler IBM manuals on mainframe assembler language.
PPR: Learning Assembly Language
An Introduction to Writing 32-bit Applications Using the x86 Assembly Language
Assembly Language Programming Examples
Authoring Windows Applications In Assembly Language
Information on Linux assembly programming
x86 Instruction Set Reference
Iczelion's Win32 Assembly Tutorial
Assembly Optimization Tips by Mark Larson
NASM Manual
Microchip PIC assembly coding basics
Z80/Z180/8085 Assembler

{{Programming language}}{{DEFAULTSORT:Assembly Language}}


ar:??? ?????
bn:??????????? ????
bs:Assembler
bg:????????
ca:Llenguatge assemblador
cs:Jazyk symbolických adres
da:Assemblersprog
de:Assemblersprache
et:Assemblerkeel
el:Assembly (?????? ???????????????)
es:Lenguaje ensamblador
eo:Asembla lingvo
fa:??????
fr:Assembleur
ko:?????
hi:???????? ????
hr:Asemblerski jezik
id:Bahasa rakitan
is:Smalamál
it:Assembly
he:??? ??
ka:???????
kk:???????????? ????
lv:Asamblervaloda
lt:Asemblerio kalba
hu:Assembly
ml:??????? ???
ms:Bahasa himpunan
ja:???????
no:Assembler
nl:Assembleertaal
pl:Asembler
pt:Assembly
ro:Limbaj de asamblare
ru:???? ??????????
sq:Assembly
si:????????? ?????
simple:Assembly language
sl:Zbirni jezik
sr:????????
sh:Asemblerski jezik
fi:Assembly (ohjelmointikieli)
sv:Assembler
th:?????????????
tr:Çevirici diller
uk:???? ?????????
vi:H?p ng?
zh:????